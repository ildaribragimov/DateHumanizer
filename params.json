{"name":"Phpdatehumanizer","tagline":"Человеческие даты и интервалы","body":"# PHPDateHumanizer\r\n\r\nPHPDateHumanizer — PHP-класс, который принимает на вход одну или две даты и возвращает строковую в человеческом формате. Например, на «2015-01-01, 2015-01-02» класс вернет «1—2 января 2015». Или даже «1—2 января», если речь едёт про текущий год.\r\n\r\nPHPDateHumanizer родился из необходимости красиво рендерить даты событий: в админке задается дата старта события и, если нужно, дата окончания. Класс распознаёт разные комбинации форматов. \r\n\r\nКласс убивает дубликаты на случай, если вы подали на вход в качестве начала и окончания две одинаковые даты.\r\n\r\nСейчас PHPDateHumanizer работает только с одиночными датами и с интервалами. Будет здорово, если найдется кто-нибудь, кто допишет нужный код, который позволит работать с любым количеством дат, поступающим на вход:\r\n\r\n* Если на вход подана одна дата — то это без вариантов одна точечная дата.\r\n* Если на вход поданы две даты — это интервал и его нужно рендерить как промежуток, с тире\r\n* Если на вход поданы три и более дат — их нужно рендерить через запятую: «1,2 и 3 июля»,  «Сентябрь, октябрь и декабрь 2011» и так далее.\r\n\r\n## Работа с классом\r\n\r\n1. Скачайте\r\n2. Подключите\r\n\r\n```\r\nrequire_once( 'PhpDateHumanizer.php' );\r\n```\r\n\r\n3. Создайте экземпляр класса с нужными опциями:\r\n\r\n```\r\n$arg = array(\r\n    'dates' => array( '2014-02-12T19:00:00', '2014-02-13T19:00:00' ),\r\n    'timezone' => 'Asia/Tokyo'\r\n);\r\n$date = new PhpDateHumanizer( $arg );\r\necho $date->output;\r\n```\r\n\r\n## Опции\r\n\r\n* `dates` — массив дат.\r\n* `show_this_year` — скрывать год, если он совпадает с текущим. По умолчанию true.\r\n* `use_alias` — «вчера», «сегодня», «завтра» вместо дат.\r\n* `timezone` — нужна для корректной работы функции `date()` и применяется только для определения синонимов «Сегодня», «Вчера», «Завтра». Она никак не повлияет на часы и минуты, которые будут вы передадите в массиве `dates`. По умолчанию `timezone` равен `UTC`.\r\n* `lang` — массив строковых для локализации. По умолчанию класс возвращает строчку на английском языке. Чтобы работать с русским языком, нужно передать в опции `lang` такой массив:\r\n\r\n```\r\n'lang'              => array(\r\n    'since'             => 'с',\r\n    'till'              => 'по',\r\n    'at'                => 'в',\r\n    'today'             => 'Сегодня',\r\n    'tomorrow'          => 'Завтра',\r\n    'yesterday'         => 'Вчера',\r\n    'nounSeparator'     => '&nbsp;&mdash; ',\r\n    'numberSeparator'   => '&mdash;',\r\n    'nominative'        => array( 'январь', 'февраль', 'март', 'апрель', 'май', 'июнь', 'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь' ),\r\n    'genitive'          => array( 'января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря')\r\n)\r\n```\r\n\r\n# Известные проблемы\r\n\r\n* Как написано выше, остается открытым вопрос в случае, когда переданных дат больше двух.\r\n* Капитализация первой буквы: для кириллицы в PHP это сделано через жопу. Поэтому делайте первую букву большой, если это нужно, через CSS.\r\n* Порядок слов на выходе как часть языкового пресета. Например, в английском языке дата пишется в формате «February 14, 2015», в русском — «14 февраля 2015». \r\n\r\nВсе баги, пулл-реквесты и все остальное на Гитхабе.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}